Excellent. For an **academic paper**, your methodology section must be precise, rigorous, and transparent. Here’s a refined and expanded version of the **methodology** tailored for academic submission:

---

## **4. Methodology**

### **4.1 Policy Background and Research Design**

In April 2018, the UK government implemented the **Minimum Energy Efficiency Standard (MEES)**, which prohibits landlords from letting residential properties with an **Energy Performance Certificate (EPC) rating below E**. This regulation constitutes an exogenous policy shock to part of the rental market and forms the basis of our identification strategy.

We exploit this regulatory change using a **Difference-in-Differences (DiD)** framework, comparing the evolution of outcomes for **non-compliant properties (EPC F or G pre-policy)** and **compliant properties (EPC E or above pre-policy)** before and after MEES enforcement.

This strategy assumes that, in the absence of the MEES regulation, treated and control properties would have followed **parallel trends** in key outcomes.

---

### **4.2 Sample and Data Construction**

We use panel data on rental property listings across England between **2015 and 2021**, drawing from EPC records and listing platforms. Properties are identified through a unique ID and tracked across time. Our final analytic sample excludes:

* Listings with missing or inconsistent EPC records.
* New-build properties or student-specific listings, which may be governed by separate regulations.
* Properties outside England, to ensure uniform policy exposure.

---

### **4.3 Defining Treatment and Outcome Variables**

#### **Treatment Definition**

The **treatment group** comprises properties with a pre-policy EPC rating of **F or G**. These properties are directly targeted by MEES and are legally required to upgrade to **at least EPC E** to remain on the rental market.

The **control group** includes properties with pre-policy EPC ratings of **E or above**, which were not affected by the regulation.

#### **Outcome Categories**

We categorize post-policy outcomes for properties initially rated F or G into three mutually exclusive classes:

1. **Upgrade**: Properties upgraded to EPC E or above.
2. **Exit**: Properties that are no longer listed in the post-policy period, assumed to have exited the rental market.
3. **Non-Compliance**: Properties that remain listed but still have an EPC rating below E.

These outcomes allow us to examine both **compliance behaviour** and **market exits** in response to MEES.

---

### **4.4 Empirical Strategy**

#### **4.4.1 Baseline DiD Estimation**

We begin with a standard DiD model to estimate the average treatment effect on binary outcomes such as upgrade or market exit:

$$
Y_{it} = \alpha + \beta_1 \text{Treated}_i + \beta_2 \text{Post}_t + \delta (\text{Treated}_i \times \text{Post}_t) + \mathbf{X}_{it}'\gamma + \epsilon_{it}
$$

* $Y_{it}$: outcome (e.g., upgrade status, market presence, price)
* $\text{Treated}_i$: 1 if property was F/G before 2018, 0 otherwise
* $\text{Post}_t$: 1 if year ≥ 2018
* $\delta$: DiD coefficient of interest
* $\mathbf{X}_{it}$: vector of covariates (e.g., property type, age, region, student/newbuild flags)

#### **4.4.2 Multinomial Logit for Compliance Behaviour**

To analyse heterogeneous responses within the treated group, we estimate a **multinomial logistic model** on properties initially rated F or G. The dependent variable indicates the compliance outcome:

$$
\Pr(Y_i = k) = \frac{e^{\mathbf{X}_i'\beta_k}}{\sum_{j=1}^K e^{\mathbf{X}_i'\beta_j}}, \quad k \in \{\text{Upgrade}, \text{Exit}, \text{Non-Compliance}\}
$$

This allows us to explore how property characteristics (e.g., type, age, region) are associated with compliance strategies.

#### **4.4.3 Price Effects Conditional on Compliance**

We also estimate whether MEES-compliant upgrades yield a price premium. This is done by comparing the average listing prices before and after MEES for upgraded versus non-upgraded properties:

$$
\log(\text{Price}_{it}) = \alpha + \delta_1 \text{Upgrade}_i + \delta_2 \text{Post}_t + \delta_3 (\text{Upgrade}_i \times \text{Post}_t) + \mathbf{X}_{it}'\gamma + \epsilon_{it}
$$

---

### **4.5 Assumptions and Validation**

#### **4.5.1 Parallel Trends Assumption**

We test the **parallel trends assumption** by examining pre-treatment trends in key outcomes (e.g., listing price, EPC upgrades) between treated and control properties. This is supported by graphical diagnostics and placebo DiD estimations using pre-2018 data.

#### **4.5.2 Robustness Checks**

* Excluding regions with high student housing concentrations.
* Dropping properties with missing or inconsistent EPC records.
* Placebo policy implementation years (e.g., fake treatment in 2016).
* Triple-differences model incorporating additional market segments.

---

### **4.6 Limitations**

* Exit is observed as disappearance from listing data, which may also reflect a sale or off-market status.
* EPC records may not capture unofficial upgrades or exemptions (e.g., listed buildings).
* DiD relies on assumption of no spillovers from treated to control properties.

---

Would you like me to help you structure the **data section**, or expand this with **formal hypotheses** and how they link to each estimation strategy?

Great — designing the dataset structure is a crucial step to ensure your methodology is executable and your estimates valid.

Here’s a suggested **panel-style dataset format**, tailored to your DiD and multinomial analysis of the **MEES policy** impact on the UK rental market:

---

## ✅ **Dataset Format: Panel Data (Property × Time)**

Each row should represent a **property-year** observation (or property-quarter if you use finer time resolution).

### 🔹 **Column Schema (Variables)**

| Column Name           | Type        | Description                                                                 |
| --------------------- | ----------- | --------------------------------------------------------------------------- |
| `property_id`         | string      | Unique ID for each property (persistent over time)                          |
| `year` / `quarter`    | int         | Time period (e.g., 2017, 2018, 2019)                                        |
| `post_policy`         | binary      | =1 if year ≥ 2018 (post-MEES), 0 otherwise                                  |
| `treated`             | binary      | =1 if the property's EPC was F/G before 2018                                |
| `initial_epc`         | string      | Original EPC rating before MEES (A-G)                                       |
| `current_epc`         | string      | EPC rating in the current period (A-G), or `NaN` if not relisted            |
| `epc_upgrade`         | binary      | =1 if EPC improved from F/G to E or better                                  |
| `status`              | string      | Rental status: `Available`, `Let Agreed`, or `Removed` (e.g., not relisted) |
| `compliance_outcome`  | categorical | `Upgraded`, `Still Non-Compliant`, or `Removed`                             |
| `log_rent`            | float       | Log of the listing rent (if available)                                      |
| `region`              | string      | Region in England (e.g., London, East Midlands)                             |
| `property_type`       | string      | e.g., Flat, Detached, Terraced, Semi-Detached                               |
| `construction_year`   | int         | Year of construction                                                        |
| `is_student_property` | binary      | =1 if student housing, 0 otherwise                                          |
| `is_newbuild`         | binary      | =1 if newly built property                                                  |
| `listed`              | binary      | =1 if property is listed in that year, 0 otherwise                          |
| `listing_count`       | int         | Number of times this property appeared in listings that year                |

---

### 🔸 **Example (Wide View)**

| property\_id | year | post\_policy | treated | initial\_epc | current\_epc | epc\_upgrade | compliance\_outcome | status     | log\_rent | ... |
| ------------ | ---- | ------------ | ------- | ------------ | ------------ | ------------ | ------------------- | ---------- | --------- | --- |
| A123         | 2017 | 0            | 1       | G            | G            | 0            | Still Non-Compliant | Available  | 6.45      | ... |
| A123         | 2019 | 1            | 1       | G            | E            | 1            | Upgraded            | Let Agreed | 6.90      | ... |
| B456         | 2016 | 0            | 0       | E            | E            | 0            | Control             | Available  | 6.70      | ... |
| B456         | 2020 | 1            | 0       | E            | E            | 0            | Control             | Let Agreed | 6.75      | ... |
| C789         | 2017 | 0            | 1       | F            | F            | 0            | Still Non-Compliant | Available  | 6.50      | ... |
| C789         | 2019 | 1            | 1       | F            | NaN          | 0            | Removed             | Removed    | NaN       | ... |

---

## 📌 Key Notes

* **`treated`** is fixed for each property, based on pre-2018 EPC.
* **`post_policy`** changes with time (e.g., 1 from 2018 onward).
* **`compliance_outcome`** is determined only **post-policy** for treated properties:

  * If EPC improves: `'Upgraded'`
  * If property not listed anymore: `'Removed'`
  * If still EPC F/G: `'Still Non-Compliant'`
* **`epc_upgrade`** is useful for binary DiD.
* **`log_rent`** allows you to study price dynamics and premiums.
* **`listed`** or `status` helps determine exit from the market.

---

## 🛠 Optional Enhancements

* **`time_to_upgrade`**: Number of quarters or years from policy start to upgrade.
* **`price_per_m2`**: If floor area is available.
* **`local_epc_average`**: Regional or postcode-level EPC mean to control for location quality.
* **`market_exit`**: =1 if property disappears for ≥2 years post-policy.

---

Would you like help with:

* Building this dataset in Python (e.g., from EPC + Zoopla listings)?
* Automating the compliance classification logic?
* Sample synthetic dataset to test your code on?

Let me know how you'd like to proceed.



✅ Noted: your unit of analysis is **`flat_id × year`**, and when a flat has **multiple listings within the same year**, you'll keep only the **most recent** one.

Would you like a Python snippet to filter your dataset accordingly? I can help ensure you retain just one observation per flat-year (based on the latest listing date).


Here’s a clean **Python snippet** to help you:

> ✅ Keep only the **most recent listing** per `flat_id × year`.

Assumes you have:

* A DataFrame `df`
* Columns: `'flat_id'`, `'year'`, and `'listing_date'` (as a datetime)

---

### 🐍 Python Code

```python
import pandas as pd

# Ensure listing_date is in datetime format
df['listing_date'] = pd.to_datetime(df['listing_date'])

# Sort so most recent listing comes first
df_sorted = df.sort_values(by=['flat_id', 'year', 'listing_date'], ascending=[True, True, False])

# Drop duplicates — keep most recent listing per flat-year
df_deduped = df_sorted.drop_duplicates(subset=['flat_id', 'year'], keep='first')

# Optional: reset index
df_deduped = df_deduped.reset_index(drop=True)

print(f"Filtered data: {df_deduped.shape[0]} unique flat-year observations")
```

---

### ✅ Output

Now `df_deduped` contains:

* Exactly **one row per `flat_id × year`**
* Always the **most recent listing** from that year

---

Let me know if:

* Your date column has a different name (e.g. `'date_listed'`)
* You want to add a step to compare rent changes between years per flat

I'm happy to customize the code further.
Great — here’s how to **compare rent changes between years for each flat** after deduplication. This will compute:

> **Δ rent = current year’s rent – previous year’s rent** for each `flat_id`

---

### 🐍 Updated Python Code

Assumes:

* `df_deduped` contains one row per `flat_id × year`
* Column `rent` (or `log_rent`) is your outcome variable

---

#### ✅ 1. Compute Rent Change (`delta_rent`)

```python
# Sort data for group-wise operations
df_deduped = df_deduped.sort_values(by=['flat_id', 'year'])

# Group by flat_id and calculate year-over-year rent change
df_deduped['delta_rent'] = df_deduped.groupby('flat_id')['rent'].diff()

# Optional: log rent change (useful for percentage interpretation)
df_deduped['delta_log_rent'] = df_deduped.groupby('flat_id')['log_rent'].diff()

# Inspect example
df_deduped[['flat_id', 'year', 'rent', 'delta_rent']].head(10)
```

---

### 📊 Interpretation

| flat\_id | year | rent | delta\_rent |
| -------- | ---- | ---- | ----------- |
| F001     | 2016 | 1000 | NaN         |
| F001     | 2017 | 1050 | 50          |
| F001     | 2019 | 1100 | 50          |
| F002     | 2017 | 900  | NaN         |
| F002     | 2019 | 1000 | 100         |

You can now use `delta_rent` as an additional outcome in robustness checks or event studies.

---

Let me know if:

* You want to compute **percentage change**
* You’re using **weekly or monthly rent** and want to annualize
* You want a **lag of EPC rating or treatment status** to match rent effect

Happy to expand!



def remove_repeated_segments(address):
    parts = [part.strip() for part in address.split(',')]
    seen = set()
    unique_parts = []
    for part in parts:
        part_lower = part.lower()
        if part_lower not in seen:
            seen.add(part_lower)
            unique_parts.append(part)
    return ', '.join(unique_parts)

# Apply to DataFrame
df['clean_address'] = df['address'].apply(remove_repeated_segments)


import zipfile
import pandas as pd

# Path to your ZIP file
zip_path = 'your_file.zip'

# List to collect DataFrames
df_list = []

# Define columns to read (case-sensitive match to CSV header)
use_columns = ['Postcode', 'LocalAuthority', 'Address', 'UPRN']  # adapt as needed

with zipfile.ZipFile(zip_path, 'r') as z:
    for file_name in z.namelist():
        if file_name.endswith('.csv'):
            with z.open(file_name) as f:
                try:
                    df = pd.read_csv(f, usecols=use_columns)
                    df['source_file'] = file_name  # optional
                    df_list.append(df)
                except ValueError:
                    print(f"⚠️ Skipping file (missing columns): {file_name}")

# Combine all DataFrames
final_df = pd.concat(df_list, ignore_index=True)

# Preview
print(final_df.head())



Your text is already well-structured and clear. Below is a lightly edited version to improve flow, grammar, and consistency. I've preserved the structure and detail, just tightening the language for academic or professional writing:

---

We use rental listing data from **Rightmove UK**, covering the period **2005 to 2021**, comprising approximately **14 million transactions**. To enrich this dataset with energy performance information, we merge it with the **Energy Performance Certificate (EPC)** database using the **Unique Property Reference Number (UPRN)** as the linking key.

However, many listings in the Rightmove data are missing UPRNs. To address this, we employ an **address-matching algorithm** that links the listing data to the EPC dataset by matching key address components (e.g., street name, postcode, building number). This allows us to infer UPRNs for listings with missing values. We validate the quality of the imputed UPRN variable by comparing it with the original UPRNs available in the listing data. The two variables exhibit a high correlation (ρ = 0.94), providing strong support for the reliability of our address-based UPRN matching procedure. We use these matched UPRNs to fill in the missing values in the listing data.

We drop listings for which we are unable to identify a valid UPRN, as these properties cannot be matched to an EPC record and are therefore excluded from the analysis.

Next, we construct a **unique property identifier** based on the address and number of bedrooms. Since door numbers are often missing in the listing data, we rely on a combination of address components and bedroom count to distinguish between properties. This approach helps differentiate listings that share the same address but likely correspond to different units within the same building.

In cases where a property (defined by address and bedroom count) is listed multiple times within the same calendar year, we aggregate these entries into a single observation. We compute the **average listing price** for the year and retain the **modal value** for all categorical variables.

We then divide the listing data into two periods: **pre-policy** and **post-policy**, based on the implementation date of the **Minimum Energy Efficiency Standard (MEES)** on **April 1, 2018**. Listings dated **before April 30, 2018** are matched with EPC records whose inspection dates also fall **before April 30, 2018**, ensuring temporal alignment between the rental listing and the EPC assessment.

For **post-policy listings** (after April 30, 2018), we primarily match them with EPC ratings based on inspections conducted **after April 30, 2018**. However, in cases where a post-policy listing does not have a corresponding match in the post-policy EPC data, we allow it to be matched with its **pre-policy EPC rating**. This accounts for properties that have not undergone a new EPC inspection since the policy came into effect. In such cases, the most recent available EPC rating remains the relevant reference point.

---

Let me know if you'd like help with citations, figures, or a corresponding methodology diagram for this section.
Great — you're building a solid foundation for causal inference and outcome classification. Here's a refined and extended version of your paragraph that integrates it into a research-methods style section:

---

### Post-Policy Observation and Outcome Classification

Not all properties in our sample are observed in the post-policy period. To understand the varied responses to the **Minimum Energy Efficiency Standard (MEES)**, we focus on the subset of **pre-policy non-compliant properties**—those with an **EPC rating of F or G**—and categorize their **post-policy outcomes** into three mutually exclusive groups:

1. **Upgrade**: The property remains in the rental market and is associated with an EPC rating of **E or higher** in the post-policy period, indicating that the landlord undertook energy efficiency improvements to bring the property into compliance.

2. **Exit**: The property is **no longer listed** for rent in the post-policy period and is not associated with a recent EPC inspection, suggesting that it may have **exited the formal rental market**—either withdrawn, sold, or repurposed.

3. **Non-Compliance**: The property remains actively listed post-policy but retains an **EPC rating of F or G**, implying **ongoing non-compliance** with MEES regulations.

This outcome framework allows us to distinguish between **compliance behavior** (upgrading vs. remaining non-compliant) and **market participation** (remaining in vs. exiting the rental market) in response to the regulatory change. It also facilitates a richer analysis of landlord responses by tracking how the most directly affected properties adapted—or failed to adapt—to the policy environment.

---

Would you like help writing an empirical strategy for estimating the effect of MEES on these outcomes (e.g., multinomial logit, survival analysis, etc.)?
Certainly! Here's an elaborated and polished version of the sentence, integrated into the same formal academic tone and flow as your previous methodology section:

---

To construct a credible comparison between treated and control groups, we implement **propensity score matching (PSM)**. This method addresses potential selection bias by ensuring that treated and control properties are comparable on observable characteristics.

We define **treated properties** as those that are **non-compliant with the MEES regulation prior to April 2018**—typically those with an EPC rating of **F or G**—and that are subsequently observed in the **post-policy** period. The **control group** comprises properties that were already compliant with the regulation before its implementation (typically rated **E or better**) and are also observed in the post-policy period.

We estimate the **propensity score** for each property—the probability of being treated—using a **logistic regression model**. The covariates include a rich set of pre-policy property characteristics such as:

* Number of bedrooms
* Property type (e.g., flat, detached, terraced)
* Location (postcode district fixed effects)
* Year fixed effects
* Pre-policy average listing price
* Observed energy efficiency sub-metrics (e.g., wall/roof insulation, heating system type) if available

Each treated property is then matched to one or more control properties with similar propensity scores using **nearest-neighbor matching** without replacement and a caliper to restrict poor matches. We assess **covariate balance** before and after matching to ensure that the treatment and control groups are statistically comparable.

This matching procedure enables us to estimate the **average treatment effect on the treated (ATT)** by comparing post-policy outcomes (e.g., listing prices) between treated and matched control units, holding observed pre-policy characteristics constant.

---

Let me know if you'd like this expanded with matching diagnostics (e.g., standardized mean differences, visual plots), or code snippets in Stata, R, or Python for implementation.

import pandas as pd
from datetime import datetime

# Assume df contains all listings from 2005–2021
cutoff_date = pd.to_datetime("2018-04-30")

# 1. Tag pre-policy F/G rated properties as treated
df["epc_date"] = pd.to_datetime(df["epc_date"])
df["listing_date"] = pd.to_datetime(df["listing_date"])

df["pre_policy"] = df["listing_date"] <= cutoff_date
df["post_policy"] = df["listing_date"] > cutoff_date
df["treated"] = (df["pre_policy"]) & (df["epc_rating"].isin(["F", "G"]))

# 2. Reduce to treated properties only
treated_df = df[df["treated"]]

# 3. For each treated property, identify the outcome
def classify_outcome(group):
    post_policy_rows = group[group["post_policy"]]
    if post_policy_rows.empty:
        return "Exit"
    elif any(post_policy_rows["epc_rating"].isin(["A", "B", "C", "D", "E"])):
        return "Upgrade"
    else:
        return "Non-Compliance"

# Apply classification
outcome_df = treated_df.groupby("property_id").apply(classify_outcome).reset_index()
outcome_df.columns = ["property_id", "post_policy_outcome"]

# Merge back
df = df.merge(outcome_df, on="property_id", how="left")

# Optional: convert to numeric codes
outcome_map = {"Exit": 0, "Non-Compliance": 1, "Upgrade": 2}
df["outcome_code"] = df["post_policy_outcome"].map(outcome_map)
